有时候如果网站并发访问高，一个缓存如果失效，
可能出现多个进程同时查询DB，同时设置缓存的情况，
如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。
并且最严重的是，如果是对同一个key做rpush,incr等操作则会造成数据错误

例子：
优惠券列表在Redis中以List的形式存储，查询时的逻辑很简单：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.把查询数据库的结果循环放入缓存
然而，当某个时间点缓存不存在，请求量又很大的时候，会出现缓存并发的问题。也就是多个线程会重复去查询DB，又重复去更新缓存。
这其中重复查询DB是次要问题，而重复更新缓存则是主要问题。假如有两个线程同时进入上述的第三个阶段，
各自进行rpush操作，
那么最终会在优惠券列表的缓存中插入两组同样的数据。


归纳一下修改后的逻辑：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.争夺分布式锁
4.成功获得锁，把查询数据库的结果循环放入缓存
5.释放分布式锁
这样问题依然存在，只不过是进程被堵塞，还是会写两次（即两个进程都进入，一个在代码块（锁）前，一个写完刚好释放锁）


最终的逻辑为双重检测
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.争夺分布式锁
4.成功获得锁，再次判断缓存的存在
5.如果缓存仍旧不存在，把查询数据库的结果循环放入缓存
6.释放分布式锁

 1. setnx(lockkey, 当前时间+过期超时时间) ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2。

 2. get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向3。

 3. 计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime。

 4. 判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。

 5. 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。


 有的时候会为了方便写库时不修改redis，而进行读一遍然后去重置key value
 这会有一个问题：若db主从延迟则会导致放到redis中是旧的。