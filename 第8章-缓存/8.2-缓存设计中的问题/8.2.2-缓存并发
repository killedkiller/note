有时候如果网站并发访问高，一个缓存如果失效，
可能出现多个进程同时查询DB，同时设置缓存的情况，
如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。
并且最严重的是，如果是对同一个key做rpush,incr等操作则会造成数据错误

例子：
优惠券列表在Redis中以List的形式存储，查询时的逻辑很简单：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.把查询数据库的结果循环放入缓存
然而，当某个时间点缓存不存在，请求量又很大的时候，会出现缓存并发的问题。也就是多个线程会重复去查询DB，又重复去更新缓存。
这其中重复查询DB是次要问题，而重复更新缓存则是主要问题。假如有两个线程同时进入上述的第三个阶段，
各自进行rpush操作，
那么最终会在优惠券列表的缓存中插入两组同样的数据。


归纳一下修改后的逻辑：
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.争夺分布式锁
4.成功获得锁，把查询数据库的结果循环放入缓存
5.释放分布式锁
这样问题依然存在，只不过是进程被堵塞，还是会写两次（即两个进程都进入，一个在代码块（锁）前，一个写完刚好释放锁）


最终的逻辑为双重检测
1.查询缓存，如果缓存存在，返回结果
2.缓存不存在，查询数据库
3.争夺分布式锁
4.成功获得锁，再次判断缓存的存在
5.如果缓存仍旧不存在，把查询数据库的结果循环放入缓存
6.释放分布式锁