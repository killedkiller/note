1.基于RDB的主从复制流程
 
1）复制初始化
Slave：Slave启动后，向Master发送SYNC命令；
Master：
Master收到SYNC命令后，开启后台线程，保存RDB快照，缓存快照期间收到的命令；
当快照完成后，Master将RDB连同缓存命令一起发送给Slave;
Slave：
Slave将接收到数据写入临时文件；
当文件写完之后，用临时文件替换当前RDB文件；
Slave重新加载RDB文件数据；
 
注：Slave同步数据过程中不会阻塞，而是继续使用同步前的数据作应答；可以通过slave-serve-stale-data设置在同步过程中对所有请求命令回复错误；
 
具体命令：
Slave —> Master  
PING
Master —> Slave  
PONG
Slave —> Master  如果主库需要验证，才发送；
AUTH
…
Slave —> Master  
REPLCONF listening-port ${port}
Master —> Slave
OK
Slave —> Master  
SYNC
Master —> Slave
快照文件二进制数据，缓存命令
 
注：redis服务器使用TCP协议通信，故可以使用telnet工具伪装成客户端或者Slave与Master进行通信；
 
2）复制同步阶段
运行过程中，Master执行的任何写命令都会异步传送给Slave。复制同步阶段会贯穿主从同步始终，直到主从关系终止；
 
注：在主从同步过程中，只要执行复制，就会生成快照；
 
补充：乐观复制
1）redis主从复制使用乐观复制，容忍一段时间内，主从数据库中内容不同，但两者最终会同步；
2）主从同步是异步的，当主数据库接收客户端请求后返回数据，并将命令异步传递给从数据库，此时，存在主从数据不一致的时间窗口；
3）由于是异步操作，主数据库无法指导命令同步给了多少从数据库；
4）在redis2.8+版本中，可以通过min-slaves-to-write <count>设置命令至少同步给几个slave时，主数据库才是可写的；
5）在redis2.8+版本中，可以通过min-slaves-max-lag <seconds>设置允许从数据库最长失去连接的时间，即从数据库上一次发送REPLCONF ACK命令到现在的时间是否超过了该值，如果超过该值，则视作断连；
6）如上两个配置配合使用，保证主从复制的一致性；
 
2.基于RDB的主从复制特殊场景--Slave断线重连
2.6版本：重新执行复制初始化；
2.8+版本：增量复制，仅将Slave断线后的写命令发送给Slave，Slave执行命令完成增量同步；
 
3.基于RDB的主从复制特殊场景--Slave手工切换为Master
1）连接Slave，使用SLAVEOF NO ONE，终止主从关系；使Slave变为Master;
2）启动原先的Master，使用SLAVEOF命令，将其变为新Master的Slave;
 
注：当Master设置关闭持久化功能时，不要使用WatchDog之类的工具自动拉起Master进程，这会清空集群数据；
 
4.增量复制流程（version >= 2.8）
 
主从复制V2.8区别与V2.6的关键点在于主从断连后，增量复制；
设计基础
1）Slave存储Master的运行ID，每个redis运行实例都会有唯一的运行ID，实例重启后，重新分配新的运行ID；
2）在复制同步阶段，Master每将一个命令发送给Slave中，都会同时将命令存放到一个积压队列中，并记录当前积压队列中存放命令的偏移量范围。
3）Slave收到Master发来的命令后，会记录下该命令的偏移量；
 
复制流程变化
1）主从连接就绪后，Slave向Master发送psync，而非sync命令；psync命令格式：psync Master运行ID 断开前最新的命令偏移量
2）Master收到psync命令后，判断是否可以进行增量复制；判断条件如下：
Slave传过来的运行ID是否和当前Master的运行ID相同；—>确保Slave确实和Master同步过，防止Master重启等情况，导致数据不一致；
Slave传过来的命令偏移量是否在积压队列中；—>判断偏移量是否已经超过缓冲区范围，是否能够进行增量复制；
如果上述两个条件有一个判断为否，则执行全量同步；当且仅当两个判断条件均为是时，才执行增量同步；
 
积压队列（Backlog）
1）积压队列在本质上是一个固定长度的循环队列，默认大小为1MB；
2）可以通过repl-backlog-size配置来调整；
3）积压队列仅在第一次使用时初始化，积压队列越大，允许的主从断连时间越长；故需要根据主从之间的网络状态设置合适的大小；
4）因为积压队列存储的内容是命令本身，所以估算积压队列的大小只需要估算主从断连期间，执行命令的大小即可；
5）repl-backlog-ttl配置设置当所有slave都与master断连后，经过多长时间可以释放master的backlog空间；默认为1h，如果设置为0,则表示永远不释放；
 
问：如果释放后，有slave连接，master的处理流程是怎样的？
 
 
问：backlog中仅存放命令本身，如何判断是否存在偏移呢？
 
 
5.无硬盘复制（version >= 3.0）
1）背景：基于RDB主从复制的缺点
数据一致性考虑：RDB文件并不是实时写入的，所以当使用RDB文件进行主从复制时，可能造成主从数据库数据不一致情况；
性能考虑：硬盘IO效率可能成为性能瓶颈；
 
2）无硬盘复制
redis3.0+版本提供无硬盘复制功能；
当Master与Slave进行复制初始化时，不生成RDB文件，而是直接通过网络，发送数据给Slave；
 可以通过repl-diskless-sync <yes|no>设置是否开启无硬盘复制；
无硬盘复制适合于慢硬盘快网络的场景；
 
注：无硬盘复制当前处于实验阶段，慎用



一主多从集群模式可以实现数据冗余备份和读写分离，但是当主因为异常宕机时，需要通过人为手工切换的方式，将Slave变为Master，继续提供服务；使用此方式可服务性相对较差，耗费额外人力在重复工作上，且容易出错；故需要提供一套用于监控管理主从切换的自动化工具，提供集群可用性；
 
2.哨兵（sentinel）
1）redis提供了哨兵用来管理集群中主从切换；V2.8发布稳定版；
2）功能：
监控主从数据库是否正常运行；
主数据库出现故障时，自动将从数据库转换为主数据库；
3）在一套一主多从的redis系统中，可以采用多个哨兵进行监控，以提高可用性，哨兵不仅监控主从数据库，也会相互监控哨兵；
 
3.sentinel.conf
格式：sentinel monitor master名称 master地址 master端口 quorum
 
1）一个哨兵节点可以监控多个master，只需添加多条配置；
2）quorum：表示故障恢复操作前，至少需要几个哨兵节点同意；
3）哨兵配置监控一个主从系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库；
4）多个哨兵节点可以监控同一个主从系统；
 